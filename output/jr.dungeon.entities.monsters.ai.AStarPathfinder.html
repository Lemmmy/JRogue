<HTML>
<HEAD>
<TITLE>JDocCoverage Report - 14-Mar-2017 09:54:02</TITLE>
<link rel='stylesheet' type='text/css' href='default.css'>
</HEAD>
<BODY>
<TABLE cellspacing='0' class='header'><TR><TD class='title'>JDocCoverage Report - 14-Mar-2017 09:54:02</TD></TR>
<TR><TD class='menu'><a class='menu' href='index.html'>Overview</a> | <a class='menu' href='jr.dungeon.entities.monsters.ai.html'>jr.dungeon.entities.monsters.ai</a></TD></TR></TABLE>
<p>
<TABLE cellspacing='0'>
<TR><TH>Name</TH><TH>method, %</TH><TH>comment, %</TH><TH>TODO</TH><TH>@see</TH></TR>

<TR><TD>jr.dungeon.entities.monsters.ai.AStarPathfinder</TD><TD>1</TD><TD>61.6% &nbsp; (3953/2469)</TD><TD>0</TD><TD>6</TD></TR>
</TABLE>
<CODE><PRE>
<span class='code'>package jr.dungeon.entities.monsters.ai;

import jr.dungeon.Level;
import jr.dungeon.tiles.TileType;
import jr.utils.Path;
import jr.utils.Utils;
import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

</span><span class='comment'>/**
 * Attempts to find and return a {@link Path} according to the
 * &lt;a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* pathfinding algorithm&lt;/a>.
 */</span><span class='code'>
public class AStarPathfinder {
	private static final float d = 1;
	private static final float d2 = (float) Math.sqrt(2);
	
</span><span class='comment'>	/**
	 * Attempts to find and return a {@link Path} according to the
	 * &lt;a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* pathfinding algorithm&lt;/a>.
	 *
	 * @param level The Level to search for a path on.
	 * @param sx The start/source X position.
	 * @param sy The start/source Y position.
	 * @param tx The destination/target X position.
	 * @param ty The destination/target Y position.
	 * @param maxSearchDistance The maximum distance allowed to search for a path within.
	 * @param allowDiagonalMovement Whether or not moving diagonally should be allowed (i.e. moving on both axis
	 *                                 simultaneously)
	 * @param avoidTiles A List of {@link TileType TileTypes} to avoid. The returned Path will never contain one of
	 *                      these tiles unless it is the source tile.
	 *
	 * @return The {@link Path} that was found, or null if one wasn't found within the maximum search distance, or it
	 * was not possible to reach the target position.
	 */</span><span class='code'>
	public Path findPath(Level level,
						 int sx,
						 int sy,
						 int tx,
						 int ty,
						 int maxSearchDistance,
						 boolean allowDiagonalMovement,
						 List&lt;TileType> avoidTiles) {
</span><span class='comment'>		// For full description of algorithm, see https://</span><span class='comment'>en.wikipedia.org/wiki/A*_search_algorithm
</span><span class='code'>		
		if (level.getTileStore().getTileType(tx, ty).getSolidity() == TileType.Solidity.SOLID) {
			return null;</span><span class='comment'> // don't do anything if we can't even go there in the first place
</span><span class='code'>		}
		
</span><span class='comment'>		// The set of nodes that have already been evaluated.
</span><span class='code'>		List&lt;Node> closed = new ArrayList&lt;>();
</span><span class='comment'>		// The set of discovered nodes that are not evaluated yet.
</span><span class='code'>		List&lt;Node> open = new ArrayList&lt;>();
		
		int width = level.getWidth();
		int height = level.getHeight();
		
</span><span class='comment'>		// Initialise every possible node in the level.
</span><span class='code'>		Node[] nodes = new Node[width * height];
		
		for (int i = 0; i &lt; width * height; i++) {
			nodes[i] = new Node(i % width, (int) Math.floor(i / width));
		}
		
</span><span class='comment'>		// We're already at the source node, so set the cost and depth to zero.
</span><span class='code'>		nodes[width * sy + sx].cost = 0;
		nodes[width * sy + sx].depth = 0;
		
</span><span class='comment'>		// Starts the list of open nodes off with the source node.
</span><span class='code'>		open.add(nodes[width * sy + sx]);
		
</span><span class='comment'>		// The target node has no parent yet.
</span><span class='code'>		nodes[width * ty + tx].parent = null;
		
</span><span class='comment'>		// While we haven't exceeded our maximum search depth,
</span><span class='code'>		int maxDepth = 0;
		
		while (maxDepth &lt; maxSearchDistance && open.size() != 0) {
</span><span class='comment'>			// pull out the first node in our open list - this is determined to be the most likely to be the next
</span><span class='code'></span><span class='comment'>			// step based on the heuristic.
</span><span class='code'>			
			Node current = open.get(0);
			
			if (current == nodes[width * ty + tx]) {
</span><span class='comment'>				// We've reached the target.
</span><span class='code'>				break;
			}
			
</span><span class='comment'>			// Take the current node out of the open nodes list, and put it in the closed nodes list.
</span><span class='code'>			open.remove(current);
			closed.add(current);
			
</span><span class='comment'>			// Search through the adjacent tiles.
</span><span class='code'>			for (int x = -1; x &lt; 2; x++) {
				for (int y = -1; y &lt; 2; y++) {
</span><span class='comment'>					// The current tile is not a neighbour.
</span><span class='code'>					if (x == 0 && y == 0) {
						continue;
					}
					
</span><span class='comment'>					// If diagonal movement is not allowed, don't check a tile where both axis deltas are nonzero.
</span><span class='code'></span><span class='comment'>					// In other words, only one of x or y can be set.
</span><span class='code'>					if (!allowDiagonalMovement) {
						if (x != 0 && y != 0) {
							continue;
						}
					}
					
					int xp = x + current.x;
					int yp = y + current.y;
					
</span><span class='comment'>					// Check if the tile is in the map, non-solid, and not in the list of tiles to avoid.
</span><span class='code'>					if (isValidLocation(level, xp, yp, avoidTiles)) {
</span><span class='comment'>						// The cost to get to this node is the current node's cost plus the movement cost to reach
</span><span class='code'></span><span class='comment'>						// this node. Note that the heuristic value is only used in the sorted open list.
</span><span class='code'>						float nextStepCost = current.cost + getHeuristicCost(current.x, current.y, xp, yp);
						Node neighbour = nodes[width * yp + xp];
						
</span><span class='comment'>						// Checks we haven't found a better route to a node we'd previously considered searched (i.e.
</span><span class='code'></span><span class='comment'>						// it's in the open or closed lists). If we've found a better route to the node (the cost is
</span><span class='code'></span><span class='comment'>						// less than the recorded cost), then remove it from the lists it's in to mark it as
</span><span class='code'></span><span class='comment'>						// un-searched.
</span><span class='code'>						if (nextStepCost &lt; neighbour.cost) {
							if (open.contains(neighbour)) {
								open.remove(neighbour);
							}
							
							if (closed.contains(neighbour)) {
								closed.remove(neighbour);
							}
						}
						
</span><span class='comment'>						// If the node hasn't already been processed and discarded, then reset its cost to our
</span><span class='code'></span><span class='comment'>						// current cost, and add it as a next possible step (i.e. to the open list).
</span><span class='code'>						if (!open.contains(neighbour) && !closed.contains(neighbour)) {
							neighbour.cost = nextStepCost;
							neighbour.heuristic = getHeuristicCost(xp, yp, tx, ty);
							maxDepth = Math.max(maxDepth, neighbour.setParent(current));
							open.add(neighbour);
						}
					}
				}
			}
		}
		
		if (nodes[width * ty + tx].parent == null) {
</span><span class='comment'>			// No path was found.
</span><span class='code'>			return null;
		}
		
</span><span class='comment'>		// Create and return a {@link Path} containing our nodes.
</span><span class='code'>		Path path = new Path();
		Node target = nodes[width * ty + tx];
		
</span><span class='comment'>		// Since we know the path we can traverse the parents of the target node until we reach the source to build
</span><span class='code'></span><span class='comment'>		// the path. Since we work backwards, we prepend the steps.
</span><span class='code'>		while (target != nodes[width * sy + sx]) {
			path.prependStep(level.getTileStore().getTile(target.x, target.y));
			target = target.parent;
		}
		
</span><span class='comment'>		// Finally add the source to the path too.
</span><span class='code'>		path.prependStep(level.getTileStore().getTile(sx, sy));
		
		path.lock();
		
		return path;
	}
	
</span><span class='comment'>	/**
	 * Checks if the specified position is a valid location to move in the {@link Level}. Also checks if the position
	 * is in the list of {@link TileType TileTypes} to avoid.
	 *
	 * @param level The level to check against.
	 * @param x The X position to check.
	 * @param y The Y position to check.
	 * @param avoidTiles The list of {@link TileType TileTypes} to avoid. Can be empty.
	 *
	 * @return Whether or not this tile can be moved to.
	 */</span><span class='code'>
	public boolean isValidLocation(Level level, int x, int y, List&lt;TileType> avoidTiles) {
		return !(x &lt; 0 || x >= level.getWidth() ||
			y &lt; 0 || y >= level.getHeight()) &&
			level.getTileStore().getTile(x, y) != null &&
			level.getTileStore().getTileType(x, y).getSolidity() != TileType.Solidity.SOLID &&
			!avoidTiles.contains(level.getTileStore().getTileType(x, y));
	}
	
</span><span class='comment'>	/**
	 * Calculates the &lt;a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)">heuristic&lt;/a> cost of
	 * moving from tile &lt;code>A&lt;/code> to tile &lt;code>B&lt;/code>. Uses the octile distance heuristic, using 1 as a cost
	 * for cardinal movements, and &lt;code>sqrt(2)&lt;/code> (&lt;code>~1.41&lt;/code>) for diagonal movements.
	 *
	 * @param ax The source X position.
	 * @param ay The source Y position.
	 * @param bx The target X position.
	 * @param by The target Y position.
	 *
	 * @return The heuristic cost for moving from A to B.
	 *
	 * @see &lt;a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)">Wikipedia article on Heuristics&lt;/a>
	 * @see &lt;a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">Page 2 of Amit's Thoughts on
	 * Pathfinding, describing A*'s use of Heuristics in game programming.&lt;/a>
	 * @see &lt;a href="http://movingai.com/astar.html">Nathan Sturtevant's article on A* tie-breaking.&lt;/a>
	 *
	 * @see Utils#octileDistance(int, int, int, int, float, float)
	 */</span><span class='code'>
	public float getHeuristicCost(int ax, int ay, int bx, int by) {
		return Utils.octileDistance(ax, ay, bx, by, d, d2);
	}
	
</span><span class='comment'>	/**
	 * Simple object for the {@link AStarPathfinder}'s nodes - embodies a point in a {@link Level}, the search depth
	 * of the node, path and heuristic cost, and parent node.
	 */</span><span class='code'>
	@Getter
	public class Node implements Comparable&lt;Node> {
</span><span class='comment'>		/** The X coordinate of the node. */</span><span class='code'>
		private int x;
</span><span class='comment'>		/** The Y coordinate of the node. */</span><span class='code'>
		private int y;
</span><span class='comment'>		/** The search depth of the node. */</span><span class='code'>
		private int depth;
</span><span class='comment'>		/** The path cost of the node. */</span><span class='code'>
		private float cost;
</span><span class='comment'>		/**
		 * The heuristic cost of the node.
		 *
		 * @see AStarPathfinder#getHeuristicCost(int, int, int, int)
		 */</span><span class='code'>
		private float heuristic;
</span><span class='comment'>		/** The parent of the node - how we reached it in the search. */</span><span class='code'>
		private Node parent;
		
</span><span class='comment'>		/**
		 * Simple object for the {@link AStarPathfinder}'s nodes - embodies a point in a {@link Level}, the search depth
		 * of the node, path and heuristic cost, and parent node.
		 *
		 * @param x The X coordinate of the node.
		 * @param y The Y coordinate of the node.
		 */</span><span class='code'>
		public Node(int x, int y) {
			this.x = x;
			this.y = y;
		}
		
</span><span class='comment'>		/**
		 * Sets the parent of this node.
		 *
		 * @param parent The parent node which led us to this node.
		 *
		 * @return The depth we have now reached in searching.
		 */</span><span class='code'>
		public int setParent(Node parent) {
			depth = parent.depth + 1;
			this.parent = parent;
			
			return depth;
		}
		
</span><span class='comment'>		/**
		 * @see Comparable#compareTo(Object)
		 */</span><span class='code'>
		public int compareTo(Node other) {
			float f = heuristic + cost;
			float of = other.heuristic + other.cost;
			
			return (int) Math.max(-1, Math.min(1, of - f));
		}
	}
}
</span>
</PRE></CODE>
</BODY>
</HTML>
