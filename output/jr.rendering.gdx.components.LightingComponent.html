<HTML>
<HEAD>
<TITLE>JDocCoverage Report - 14-Mar-2017 09:54:02</TITLE>
<link rel='stylesheet' type='text/css' href='default.css'>
</HEAD>
<BODY>
<TABLE cellspacing='0' class='header'><TR><TD class='title'>JDocCoverage Report - 14-Mar-2017 09:54:02</TD></TR>
<TR><TD class='menu'><a class='menu' href='index.html'>Overview</a> | <a class='menu' href='jr.rendering.gdx.components.html'>jr.rendering.gdx.components</a></TD></TR></TABLE>
<p>
<TABLE cellspacing='0'>
<TR><TH>Name</TH><TH>method, %</TH><TH>comment, %</TH><TH>TODO</TH><TH>@see</TH></TR>

<TR><TD>jr.rendering.gdx.components.LightingComponent</TD><TD>8</TD><TD>2.7% &nbsp; (69/2464)</TD><TD>0</TD><TD>0</TD></TR>
</TABLE>
<CODE><PRE>
<span class='code'>package jr.rendering.gdx.components;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import jr.Settings;
import jr.dungeon.Dungeon;
import jr.dungeon.Level;
import jr.dungeon.events.DungeonEventHandler;
import jr.dungeon.events.LevelChangeEvent;
import jr.rendering.gdx.GDXRenderer;
import jr.rendering.gdx.tiles.TileMap;
import jr.rendering.gdx.tiles.TileRenderer;

public class LightingComponent extends RendererComponent {
	private ShapeRenderer lightBatch;
	private SpriteBatch lightSpriteBatch;
	
	private Level level;
	
	public LightingComponent(GDXRenderer renderer, Dungeon dungeon, Settings settings) {
		super(renderer, dungeon, settings);
	}
	
	@Override
	public void initialise() {
		lightBatch = new ShapeRenderer();
		lightSpriteBatch = new SpriteBatch();
		
		lightBatch.setProjectionMatrix(camera.combined);
		lightSpriteBatch.setProjectionMatrix(camera.combined);
		
		level = dungeon.getLevel();
	}
	
	@Override
	public void render(float dt) {
		Gdx.gl.glEnable(GL20.GL_BLEND);
		Gdx.gl.glBlendFunc(GL20.GL_DST_COLOR, GL20.GL_ONE_MINUS_SRC_ALPHA);

		lightBatch.setProjectionMatrix(renderer.getCombinedTransform());
		lightBatch.begin(ShapeRenderer.ShapeType.Filled);
		
		for (int y = 0; y &lt; level.getHeight(); y++) {
			for (int x = 0; x &lt; level.getWidth(); x++) {
				if (!TileRenderer.shouldDrawTile(camera, x, y)) {
					continue;
				}
				
				TileMap tm = TileMap.valueOf(level.getTileStore().getTileType(x, y).name());
				
				if (tm.getRenderer() != null) {
					tm.getRenderer().drawLight(lightBatch, dungeon, x, y);
				}
			}
		}
		
</span><span class='comment'>		// Due to the light being drawn offset, we need additional tiles on the level borders.
</span><span class='code'>		
		for (int y = 0; y &lt; level.getHeight(); y++) {
			TileMap.TILE_GROUND.getRenderer().drawLight(lightBatch, dungeon, -1, y);
			TileMap.TILE_GROUND.getRenderer().drawLight(lightBatch, dungeon, level.getWidth() + 1, y);
		}
		
		for (int x = 0; x &lt; level.getWidth(); x++) {
			TileMap.TILE_GROUND.getRenderer().drawLight(lightBatch, dungeon, x, -1);
			TileMap.TILE_GROUND.getRenderer().drawLight(lightBatch, dungeon, x, level.getHeight() + 1);
		}
		
		TileMap.TILE_GROUND.getRenderer().drawLight(lightBatch, dungeon, -1, -1);
		
		lightBatch.end();

		lightSpriteBatch.setProjectionMatrix(renderer.getCombinedTransform());
		lightSpriteBatch.begin();
		
		for (int y = 0; y &lt; level.getHeight(); y++) {
			for (int x = 0; x &lt; level.getWidth(); x++) {
				if (!TileRenderer.shouldDrawTile(camera, x, y)) {
					continue;
				}
				
				TileMap tm = TileMap.valueOf(level.getTileStore().getTileType(x, y).name());
				
				if (tm.getRenderer() != null) {
					tm.getRenderer().drawDim(lightSpriteBatch, dungeon, x, y);
				}
			}
		}
		
		lightSpriteBatch.end();
		
		Gdx.gl.glDisable(GL20.GL_BLEND);
	}
	
	@Override
	public void update(float dt) {
		
	}
	
	@Override
	public void resize(int width, int height) {
		lightBatch.setProjectionMatrix(camera.combined);
		lightSpriteBatch.setProjectionMatrix(camera.combined);
	}
	
	@Override
	public int getZIndex() {
		return 50;
	}
	
	@Override
	public void dispose() {
		lightBatch.dispose();
		lightSpriteBatch.dispose();
	}
	
	@DungeonEventHandler
	private void onLevelChange(LevelChangeEvent e) {
		this.level = e.getLevel();
	}
}
</span>
</PRE></CODE>
</BODY>
</HTML>
