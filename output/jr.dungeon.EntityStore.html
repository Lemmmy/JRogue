<HTML>
<HEAD>
<TITLE>JDocCoverage Report - 14-Mar-2017 09:54:02</TITLE>
<link rel='stylesheet' type='text/css' href='default.css'>
</HEAD>
<BODY>
<TABLE cellspacing='0' class='header'><TR><TD class='title'>JDocCoverage Report - 14-Mar-2017 09:54:02</TD></TR>
<TR><TD class='menu'><a class='menu' href='index.html'>Overview</a> | <a class='menu' href='jr.dungeon.html'>jr.dungeon</a></TD></TR></TABLE>
<p>
<TABLE cellspacing='0'>
<TR><TH>Name</TH><TH>method, %</TH><TH>comment, %</TH><TH>TODO</TH><TH>@see</TH></TR>

<TR><TD>jr.dungeon.EntityStore</TD><TD>19</TD><TD>0.0% &nbsp; (0/3945)</TD><TD>0</TD><TD>0</TD></TR>
</TABLE>
<CODE><PRE>
<span class='code'>package jr.dungeon;

import jr.ErrorHandler;
import jr.dungeon.entities.Entity;
import jr.dungeon.entities.events.EntityAddedEvent;
import jr.dungeon.entities.events.EntityRemovedEvent;
import jr.dungeon.entities.monsters.Monster;
import jr.dungeon.entities.player.Player;
import jr.utils.Point;
import jr.utils.Serialisable;
import jr.utils.Utils;
import lombok.Getter;
import org.json.JSONArray;
import org.json.JSONObject;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.stream.Collectors;

public class EntityStore implements Serialisable {
	private Map&lt;UUID, Entity> entities;
	
	@Getter private List&lt;Entity> entityAddQueue;
	@Getter private List&lt;Entity> entityRemoveQueue;
	
	private Dungeon dungeon;
	private Level level;
	
	public EntityStore(Level level) {
		this.dungeon = level.getDungeon();
		this.level = level;
		
		entities = new HashMap&lt;>();
		entityAddQueue = new ArrayList&lt;>();
		entityRemoveQueue = new ArrayList&lt;>();
	}
	
	@Override
	public void serialise(JSONObject obj) {
		entities.values().forEach(e -> {
			JSONObject serialisedEntity = new JSONObject();
			e.serialise(serialisedEntity);
			obj.append("entities", serialisedEntity);
		});
	}
	
	@Override
	public void unserialise(JSONObject obj) {
		JSONArray serialisedEntities = obj.getJSONArray("entities");
		serialisedEntities.forEach(serialisedEntity -> unserialiseEntity((JSONObject) serialisedEntity));
	}
	
	@SuppressWarnings("unchecked")
	private void unserialiseEntity(JSONObject serialisedEntity) {
		String entityClassName = serialisedEntity.getString("class");
		int x = serialisedEntity.getInt("x");
		int y = serialisedEntity.getInt("y");
		
		try {
			Class&lt;? extends Entity> entityClass = (Class&lt;? extends Entity>) Class.forName(entityClassName);
			Constructor&lt;? extends Entity> entityConstructor = entityClass.getConstructor(
				Dungeon.class,
				Level.class,
				int.class,
				int.class
			);
			
			Entity entity = entityConstructor.newInstance(dungeon, level, x, y);
			entity.unserialise(serialisedEntity);
			addEntity(entity);
			
			if (entity instanceof Player) {
				dungeon.setPlayer((Player) entity);
			}
		} catch (ClassNotFoundException e) {
			ErrorHandler.error("Unknown entity class " + entityClassName, e);
		} catch (NoSuchMethodException e) {
			ErrorHandler.error("Entity class has no unserialisation constructor " + entityClassName, e);
		} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
			ErrorHandler.error("Error loading entity class " + entityClassName, e);
		}
	}
	
	public void processEntityQueues() {
		for (Iterator&lt;Entity> iterator = entityAddQueue.iterator(); iterator.hasNext(); ) {
			Entity entity = iterator.next();
			entities.put(entity.getUUID(), entity);
			dungeon.triggerEvent(new EntityAddedEvent(entity));
			iterator.remove();
		}
		
		for (Iterator&lt;Entity> iterator = entityRemoveQueue.iterator(); iterator.hasNext(); ) {
			Entity entity = iterator.next();
			entities.remove(entity.getUUID());
			dungeon.triggerEvent(new EntityRemovedEvent(entity));
			iterator.remove();
		}
	}
	
	public Collection&lt;Entity> getEntities() {
		return entities.values();
	}
	
	public Entity getEntityByUUID(UUID uuid) {
		return entities.get(uuid);
	}
	
	public Entity getEntityByUUID(String uuid) {
		return entities.get(UUID.fromString(uuid));
	}
	
	public List&lt;Entity> getEntitiesAt(int x, int y) {
		return entities.values().stream()
			.filter(e -> e.getX() == x && e.getY() == y)
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getEntitiesAt(Point p) {
		return entities.values().stream()
			.filter(e -> e.getPosition().equals(p))
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getMonsters() {
		return entities.values().stream()
			.filter(Monster.class::isInstance)
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getHostileMonsters() {
		return entities.values().stream()
			.filter(Monster.class::isInstance)
			.filter(e -> ((Monster) e).isHostile())
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getAdjacentEntities(int x, int y) {
		List&lt;Entity> entities = new ArrayList&lt;>();
		
		Arrays.stream(Utils.DIRECTIONS).forEach(d -> entities.addAll(getEntitiesAt(x + d[0], y + d[1])));
		
		return entities;
	}
	
	public List&lt;Entity> getAdjacentMonsters(int x, int y) {
		return getAdjacentEntities(x, y).stream()
			.filter(e -> e instanceof Monster)
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getUnwalkableEntitiesAt(int x, int y) {
		return entities.values().stream()
			.filter(e -> e.getX() == x && e.getY() == y && !e.canBeWalkedOn())
			.collect(Collectors.toList());
	}
	
	public List&lt;Entity> getWalkableEntitiesAt(int x, int y) {
		return entities.values().stream()
			.filter(e -> e.getX() == x && e.getY() == y && e.canBeWalkedOn())
			.collect(Collectors.toList());
	}
	
	public boolean addEntity(Entity entity) {
		return entityAddQueue.add(entity);
	}
	
	public boolean removeEntity(Entity entity) {
		entity.setBeingRemoved(true);
		return entityRemoveQueue.add(entity);
	}
}</span>
</PRE></CODE>
</BODY>
</HTML>
