<HTML>
<HEAD>
<TITLE>JDocCoverage Report - 14-Mar-2017 09:54:02</TITLE>
<link rel='stylesheet' type='text/css' href='default.css'>
</HEAD>
<BODY>
<TABLE cellspacing='0' class='header'><TR><TD class='title'>JDocCoverage Report - 14-Mar-2017 09:54:02</TD></TR>
<TR><TD class='menu'><a class='menu' href='index.html'>Overview</a> | <a class='menu' href='jr.dungeon.items.html'>jr.dungeon.items</a></TD></TR></TABLE>
<p>
<TABLE cellspacing='0'>
<TR><TH>Name</TH><TH>method, %</TH><TH>comment, %</TH><TH>TODO</TH><TH>@see</TH></TR>

<TR><TD>jr.dungeon.items.Item</TD><TD>24</TD><TD>0.9% &nbsp; (49/5385)</TD><TD>0</TD><TD>0</TD></TR>
</TABLE>
<CODE><PRE>
<span class='code'>package jr.dungeon.items;

import jr.JRogue;
import jr.dungeon.entities.Entity;
import jr.dungeon.entities.EntityLiving;
import jr.dungeon.events.DungeonEventListener;
import jr.dungeon.items.identity.Aspect;
import jr.dungeon.items.identity.AspectBeatitude;
import jr.utils.Persisting;
import jr.utils.RandomUtils;
import jr.utils.Serialisable;
import lombok.Getter;
import org.apache.commons.lang3.StringUtils;
import org.json.JSONArray;
import org.json.JSONObject;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

@Getter
public abstract class Item implements Serialisable, Persisting, DungeonEventListener {
	private Map&lt;Class&lt;? extends Aspect>, Aspect> aspects = new HashMap&lt;>();
	private Set&lt;Class&lt;? extends Aspect>> knownAspects = new HashSet&lt;>();
	
	private int visualID;
	private int age;

	private final JSONObject persistence = new JSONObject();
	
	public Item() {
		this.visualID = RandomUtils.random(1000);
		this.aspects.put(AspectBeatitude.class, new AspectBeatitude());
	}
	
	public void update(Entity owner) {
		if (shouldAge()) {
			age++;
		}
	}
	
	public boolean shouldAge() {
		return true;
	}
	
	public boolean isis() {
		return false;
	}
	
	public boolean beginsWithVowel(EntityLiving observer) {
		return StringUtils.startsWithAny(getName(observer, false, false), "a", "e", "i", "o", "u", "8");
	}
	
	public abstract String getName(EntityLiving observer, boolean requiresCapitalisation, boolean plural);
	
	public String getBeatitudePrefix(EntityLiving observer, boolean requiresCapitalisation) {
		if (!isAspectKnown(observer, AspectBeatitude.class)) {
			return "";
		}
		
		AtomicReference&lt;String> out = new AtomicReference&lt;>("");
		
		getAspect(AspectBeatitude.class).ifPresent(a -> {
			AspectBeatitude.Beatitude beatitude = ((AspectBeatitude) a).getBeatitude();
			String s = beatitude.name().toLowerCase();
			
			out.set((requiresCapitalisation ? StringUtils.capitalize(s) : s) + " ");
		});
		
		return out.get();
	}
	
	public abstract float getWeight();
	
	public boolean shouldStack() {
		return true;
	}
	
	public boolean equals(Item other) {
		return other.getClass() == getClass() &&
			other.getAppearance() == getAppearance() &&
			other.getAspects() == getAspects();
	}
	
	public List&lt;Aspect> getPersistentAspects() {
		return aspects.values().stream().filter(Aspect::isPersistent).collect(Collectors.toList());
	}
	
	public Optional&lt;Aspect> getAspect(Class&lt;? extends Aspect> aspectClass) {
		return Optional.ofNullable(aspects.get(aspectClass));
	}
	
	public boolean isAspectKnown(EntityLiving observer, Class&lt;? extends Aspect> aspectClass) {
		if (aspects.get(aspectClass).isPersistent()) {
			return observer.isAspectKnown(this, aspectClass);
		} else {
			return knownAspects.contains(aspectClass);
		}
	}
	
	public void addAspect(Aspect aspect) {
		aspects.put(aspect.getClass(), aspect);
	}
	
	public void observeAspect(EntityLiving observer, Class&lt;? extends Aspect> aspectClass) {
		if (!aspects.containsKey(aspectClass)) {
			return;</span><span class='comment'> // can't observe an aspect that doesn't exist!!
</span><span class='code'>		}
		
		if (aspects.get(aspectClass).isPersistent()) {
			observer.observeAspect(this, aspectClass);
		} else {
			knownAspects.add(aspectClass);
		}
	}
	
	public abstract ItemAppearance getAppearance();
	
	public abstract ItemCategory getCategory();
	
	@SuppressWarnings("unchecked")
	public static Optional&lt;Item> createFromJSON(JSONObject serialisedItem) {
		String itemClassName = serialisedItem.getString("class");
		
		try {
			Class&lt;? extends Item> itemClass = (Class&lt;? extends Item>) Class.forName(itemClassName);
			Constructor&lt;? extends Item> itemConstructor = itemClass.getConstructor();
			
			Item item = itemConstructor.newInstance();
			item.unserialise(serialisedItem);
			return Optional.of(item);
		} catch (ClassNotFoundException e) {
			JRogue.getLogger().error("Unknown item class {}", itemClassName);
		} catch (NoSuchMethodException e) {
			JRogue.getLogger().error("Item class {} has no unserialisation constructor", itemClassName);
		} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
			JRogue.getLogger().error("Error loading item class {}", itemClassName);
			JRogue.getLogger().error(e);
		}
		
		return Optional.empty();
	}
	
	@Override
	public void serialise(JSONObject obj) {
		obj.put("class", getClass().getName());
		obj.put("visualID", getVisualID());
		obj.put("age", age);
		
		JSONObject serialisedAspects = new JSONObject();
		aspects.forEach((k, v) -> {
			JSONObject serialisedAspect = new JSONObject();
			v.serialise(serialisedAspect);
			
			serialisedAspects.put(k.getName(), serialisedAspect);
		});
		obj.put("aspects", serialisedAspects);
		
		JSONArray serialisedKnownAspects = new JSONArray();
		knownAspects.forEach(a -> serialisedKnownAspects.put(a.getName()));
		obj.put("knownAspects", serialisedKnownAspects);

		serialisePersistence(obj);
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public void unserialise(JSONObject obj) {
		visualID = obj.getInt("visualID");
		age = obj.optInt("age");
		
		JSONObject serialisedAspects = obj.getJSONObject("aspects");
		serialisedAspects.keySet().forEach(aspectClassName -> {
			JSONObject serialisedAspect = serialisedAspects.getJSONObject(aspectClassName);
			
			try {
				Class&lt;? extends Aspect> aspectClass = (Class&lt;? extends Aspect>) Class.forName(aspectClassName);
				Constructor&lt;? extends Aspect> aspectConstructor = aspectClass.getConstructor();
				
				Aspect aspect = aspectConstructor.newInstance();
				aspect.unserialise(serialisedAspect);
				aspects.put(aspectClass, aspect);
			} catch (ClassNotFoundException e) {
				JRogue.getLogger().error("Unknown aspect class {}", aspectClassName);
			} catch (NoSuchMethodException e) {
				JRogue.getLogger().error("Aspect class {} has no unserialisation constructor", aspectClassName);
			} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {
				JRogue.getLogger().error("Error loading aspect class {}", aspectClassName);
				JRogue.getLogger().error(e);
			}
		});
		
		obj.getJSONArray("knownAspects").forEach(aspectClassName -> {
			try {
				Class&lt;? extends Aspect> aspectClass = (Class&lt;? extends Aspect>) Class.forName((String) aspectClassName);
				knownAspects.add(aspectClass);
			} catch (ClassNotFoundException e) {
				JRogue.getLogger().error("Unknown aspect class {}", aspectClassName);
			}
		});

		try {
			unserialisePersistence(obj);
		} catch (Exception e) {
			JRogue.getLogger().error(e);
		}
	}
	
	public Item copy() {
</span><span class='comment'>		// /shrug
</span><span class='code'>		
		JSONObject serialisedItem = new JSONObject();
		serialise(serialisedItem);
		
		Optional&lt;Item> itemOptional = createFromJSON(serialisedItem);
		return itemOptional.isPresent() ? itemOptional.get() : null;
	}

	@Override
	public JSONObject getPersistence() {
		return persistence;
	}
}
</span>
</PRE></CODE>
</BODY>
</HTML>
